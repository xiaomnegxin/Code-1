#include <stdio.h>


//递归；
//一个最简单的递归：

//int main()
//{
//	printf("h" );
//	main();				//这就是递归，自己调用自己，但是这个递归是死循环，最后会终止程序。
//	return 0;			//这是因为栈溢出了。这是递归常见的错误；
//}



//练习1：输入一个无符号数，按位数从大到小的顺序输出它的每一位数。		----------直接调用。

//分析：几个点：1.无符号数，用unsigned实现。2.实现功能：利用取余取商拆分每一个位数。
//				3.按顺序输出：如果拆一个输出一个，得到的是逆序。所以我们可以先拆，拆到最后一个的时候，从最后一个开始输出。用递归可以实现；

//void print(int x)
//{
//	if (x > 9)
//	{
//		print(x / 10);					//判断条件为x>9,是为了判断它是否为两位数。如果是，取商，去掉末尾的位数得到新的数X1。	
//										//X1作为递归中第一个print的第一个参数，继续if的判断，直到if不成立。
//										//这时跳出if，执行printf，最后一个print函数内拆分出来的是最大的位数。所以会先输出它。利用递归完成了功能。
//	}
//	printf("%d ", x % 10);
//}
//
//int main()
//{
//	unsigned int a = 0;
//	scanf("%d", &a);
//	print(a);
//
//	return 0;
//}



//练习2：不创建临时变量，求出字符串长度.

//分析：问题：1.不创建临时变量，说明不能用变量设计计数器。2.字符串一般用数组表达的，所以传值还是传址呢？
//			  3.如何实现字符串长度的计算。

//char e_all(char* abc)
//{
//	//如何实现字符串的计算。字符串读到'\0'就会停止阅读且不算长度。可以利用这个特点来设置判断条件;
//	if (*abc != '\0')
//	{
//		return 1+e_all(abc+1);				//思路：不能设置临时变量，就用返回值做文章，大致思路是：读取到一个非'\0'的字符，就返回一个1，否则返回0。
//	}										//		难点是如何读完一个字符，让函数读取下一个字符呢？这里用到的办法是指针变量+1？
//	else
//		return 0;
//
//}
//
//int main()
//{
//	//设置一个字符串。
//	char arr[] = "hello";
//	//用递归定义一个函数，计算它的长度.
//
//	//设置一个变量，接受函数返回的值。
//	int a = e_all(arr);
//
//	printf("%d", a);
//	return 0;
//}



//练习3：递归写n的阶乘

//int all(int x)
//{
//	if (x <= 1)
//		return 1;
//	else
//	{
//		return x * all(x - 1);				//把n的阶乘拆成n，和n-1阶乘。然后n-1阶乘拆出n-1，和n-2阶乘...直到拆出1.
//	}
//
//}
//
//int main()
//{
//	int a = 0;
//	
//	scanf("%d", &a);
//	int b = all(a);
//	printf("%d", b );
//	return 0;
//}




//练习4：求斐波那契数列的第n个值。
//		1,1,2,3,5,8,13,21.....

//int All(int x)					//用递归就是一个一个拆解成1，然后相加；计算量太大。不推荐用递归。
//{
//	if (x <= 2)
//		return 1;
//	else
//		return All(x - 1) + All(x - 2);
//}

//int All2(int x)
//{
//	int a = 1;
//	int b = 1;
//	int c = 0;
//	if (x <= 2)
//	{
//		return 1;
//	}
//	while (x > 2)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		x--;
//	}
//	return c;
//	
//}
//
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//
//	//实现函数：
//	//int bit = All(a);
//	int bit = All2(a);
//	printf("%d", bit);
//	
//	return 0;
//}
